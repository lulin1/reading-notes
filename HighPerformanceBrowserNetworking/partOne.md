# chapter 1 延迟与带宽

本章主要介绍对所有网络通信都有决定性影响的两个方面：延迟和带宽

	• 延迟

	分组从信息源发送到目的地所需的时间。

	• 带宽

	逻辑或物理通信路径最大的吞吐量。

![1-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/1-1.jpg)

延迟是消息（message）或分组（packet）从起点到终点经历的时间。这个定义简单明了，但却掩盖了很多有用的信息。事实上，任何系统都有很多因素可能影响传送消息
的时间。

下面看看路由器这个负责在客户端和服务器之间转发消息的设备，会牵涉哪些影响延迟的因素。
	
 	• 传播延迟
  
	消息从发送端到接收端需要的时间，是信号传播距离和速度的函数
  
	• 传输延迟
  
	把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数
  
	• 处理延迟
  
	处理分组首部、检查位错误及确定分组目标所需的时间
  
	• 排队延迟
  
	到来的分组排队等待处理的时间
  

以上延迟的时间总和，就是客户端到服务器的总延迟时间。传播时间取决于距离和信号通过的媒介，另外传播速度通常不超过光速。而传输延迟由传输链路的速率决
定，与客户端到服务器的距离无关。举个例子，假设有一个 10 MB 的文件，分别通过两个链路传输，一个 1 Mbit/s，另一个 100 Mbit/s。在 1 Mbit/s 的链路上，需要花10 s，而在 100 Mbit/s 的链路上，只需 0.1 s。


# chapter 2 TCP的构成

因特网有两个核心协议：IP 和 TCP。

IP，即 Internet Protocol（因特网协议），负责联网主机之间的路由选择和寻址；

TCP，即 Transmission Control Protocol（传输控制协议），负责在不可靠的传输信道之上提供可靠的抽象层。

TCP/IP 也常被称为“因特网协议套件”（Internet Protocol Suite），是由 Vint Cerf 和 Bob Khan 在他们1974 的论文“A Protocol for Packet Network Intercommunication”（一种分组网络互通的协议）中首次提出来的。

## 2.1 三次握手

![2-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-1.jpg)

	• SYN
	
	客户端选择一个随机序列号 x，并发送一个 SYN 分组，其中可能还包括其他 TCP标志和选项。
	
	• SYN ACK
	
	服务器给 x 加 1，并选择自己的一个随机序列号 y，追加自己的标志和选项，然后返回响应。
	
	• ACK
	
	客户端给 x 和 y 加 1 并发送握手期间的最后一个 ACK 分组。
	
	
三次握手完成后，客户端与服务器之间就可以通信了。客户端可以在发送 ACK 分组之后立即发送数据，而服务器必须等接收到 ACK 分组之后才能发送数据。这个启动通信的过程适用于所有 TCP 连接，因此对所有使用 TCP 的应用具有非常大的性能影响，因为每次传输应用数据之前，都必须经历一次完整的往返。	

三次握手带来的延迟使得每创建一个新 TCP 连接都要付出很大代价。而这也决定了提高 TCP 应用性能的关键，在于想办法重用连接。

## 2.2　拥塞预防及控制

TCP 加入了很多机制，以便控制双向发送数据的速度，比如： 流量控制、　拥塞控制　和　拥塞预防机制。

### 2.2.1  流量控制

 流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP 连接的每一方都要通告（图 2-2）自己的接收窗口（rwnd），其中包含能够保存数据的缓冲区空间大小信息。
 
 ![2-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-2.jpg)
 
 第一次建立连接时，两端都会使用自身系统的默认设置来发送 rwnd。
 
 不管怎样，如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。这个过程贯穿于每个 TCP 连接的整个生命周期：每个 ACK 分组都会携带相应的最新 rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力。
 
 ### 2.2.2 慢启动
 
 	接收窗口大小（rwnd）
	
	拥塞窗口大小（cwnd）
	
首先，三次握手，而且在此期间双方各自通过 ACK 分组通告自己的接收窗口（rwnd）大小（图 2-2）。在发送完最后一次 ACK 分组后，就可以交换应用数据了。

新 TCP 连接传输的最大数据量取 rwnd 和 cwnd 中的最小值，而服务器实际上可以向客户端发送 4 个 TCP 段，然后就必须停下来等待确认。此后，每收到一个 ACK，慢启动算法就会告诉服务器可以将它的 cwnd 窗口增加 1 个 TCP 段。每次收到 ACK后，都可以多发送两个新的分组。TCP 连接的这个阶段通常被称为“指数增长”阶段（图2-3），因为客户端和服务器都在向两者之间网络路径的有效带宽迅速靠拢。

 ![2-3.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-3.jpg)

 为什么知道有个慢启动对我们构建浏览器应用这么重要呢?因为包括 HTTP 在内的很多应用层协议都运行在 TCP 之上,无论带宽多大,每个 TCP 连接都必须经过慢启动阶段。换句话说,我们不可能一上来就完全利用连接的最大带宽!相反,我们要从一个相对较小的拥塞窗口开始,每次往返都令其翻倍(指数式增长)。而达到某个目标吞吐量所需的时间,就是客户端与服务器之间的往返时间和初始拥塞窗口大小的函数(公式 2-1)。
 
 
要达到客户端与服务器之间 64 KB 的吞吐量,需要 4 次往返(图 2-4),几百 ms 的延迟!至于客户端与服务器之间实际的连接速率是不是在 Mbit/s 级别,丝毫不影响这个结果。这就是慢启动。

 ![2-4.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-4.jpg)
 
 为减少增长到拥塞窗口的时间,可以减少客户端与服务器之间的往返时间。比如,把服务器部署到地理上靠近客户端的地方。要么,就把初始拥塞窗口大小增加到RFC 9828 规定的 10 段。

慢启动导致客户端与服务器之间经过几百 ms 才能达到接近最大速度的问题,对于大型流式下载服务的影响倒不显著,因为慢启动的时间可以分摊到整个传输周期内消化掉。

可是,对于很多 HTTP 连接,特别是一些短暂、突发的连接而言,常常会出现还没有达到最大窗口请求就被终止的情况。换句话说,很多 Web 应用的性能经常受到服务器与客户端之间往返时间的制约。因为慢启动限制了可用的吞吐量,而这对于小文件传输非常不利。


### 2.2.3 拥塞预防

认识到 TCP 调节性能 主要依赖丢包反馈机制非常重要。换句话说,这不是一个假设命题,而是一个具体何时发生的命题。慢启动以保守的窗口初始化连接,随后的每次往返都会成倍提高传输的数据量,直到超过接收端的流量控制窗口,即系统配置的拥塞阈值(ssthresh)窗口,或者有分组丢失为止,此时拥塞预防算法介入。

拥塞预防算法把丢包作为网络拥塞的标志,即路径中某个连接或路由器已经拥堵了,以至于必须采取删包措施。因此,必须调整窗口大小,以避免造成更多的包丢失,从而保证网络畅通。

重置拥塞窗口后,拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。


## 2.3 带宽延迟积

TCP 内置的　拥塞控制　和　预防机制　对性能还有另一个重要影响:　发送端和接收端理想的窗口大小,一定会因往返时间及目标传输速率而变化。

无论发送端发送的数据还是接收端接收的数据超过了未确认的最大数据量,都必须停下来等待另一方 ACK 确认某些分组才能继续。要等待多长时间呢?取决于往返时间!
	
	BDP ( Bandwidth-delay product ,带宽延迟积)
	
	数据链路的容量与其端到端延迟的乘积。这个结果就是任意时刻处于在途未确认状态的最大数据量。


### 2.4 队首阻塞

TCP 在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发,以及保证网络最高效率的流量控制、拥塞控制和预防机制,让TCP 成为大多数网络应用中最常见的传输协议。

每个 TCP 分组都会带着一个唯一的序列号被发出,而所有分组必须按顺序传送到接收端(图 2-8 )。如果中途有一个分组没能到达接收端,那么后续分组必须保存在接收端的 TCP 缓冲区,等待丢失的分组重发并到达接收端。这一切都发生在 TCP 层,应用程序对 TCP 重发和缓冲区中排队的分组一无所知,必须等待分组全部到达才能访问数据。在此之前,应用程序只能在通过 套接字 读数据时感觉到延迟交付。这种效应称为 TCP 的队首(HOL,Head of Line)阻塞。

队首阻塞造成的延迟可以让我们的应用程序不用关心分组重排和重组,从而让代码保持简洁。然而,代码简洁也要付出代价,那就是分组到达时间会存在无法预知的 延迟变化。这个时间变化通常被称为抖动,也是影响应用程序性能的一个主要因素。

无需按序交付数据或能够处理分组丢失的应用程序,以及对延迟或抖动要求很高的应用程序,最好选择 UDP 等协议。虽然 TCP 很流行,但它并不是唯一的选择,而且在某些情况下也不是最佳的选择。特别是按序交付和可靠交付有时候并不必要,反而会导致额外的延迟,对性能造成负面影响。


### 2.5 针对TCP的优化建议

TCP 是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此,优化 TCP 的最佳途径就是 调整它感知当前网络状况的方式,根据它之上或之下的抽象层的类型和需求来改变它的行为。

	尽管如此,而且每个算法和反馈机制的具体细节可能会继续发展,但核心原理以及它们的影响是不变的:
	
	• TCP 三次握手增加了整整一次往返时间;
	
	• TCP 慢启动将被应用到每个新连接;
	
	• TCP 流量及拥塞控制会影响所有连接的吞吐量;
	
	• TCP 的吞吐量由当前拥塞窗口大小控制。

尽管带宽不断增长,但延迟依旧受限于光速,而且已经限定在了其最大值的一个很小的常数因子之内。大多数情况下,TCP 的瓶颈都是 延迟,而非 带宽。

调优 TCP 性能可以让服务器和客户端之间达到最大吞吐量和最小延迟。

### 2.5.1  服务器配置调优

一句话,让你的服务器跟上时代是优化发送端和接收端 TCP 栈的首要措施。
	
### 2.5.2  应用程序行为调优

	• 再快也快不过什么也不用发送,能少发就少发。
	
	• 我们不能让数据传输得更快,但可以让它们传输的距离更短。
	
	• 重用 TCP 连接是提升性能的关键。
	
	
### 2.5.3  性能检查清单

	• 把服务器内核升级到最新版本(Linux:3.2+);
	
	• 确保 cwnd 大小为 10;
	
	• 禁用空闲后的慢启动;
	
	• 确保启动窗口缩放;
	
	• 减少传输冗余数据;
	
	• 压缩要传输的数据;
	
	• 把服务器放到离用户近的地方以减少往返时间;
	
	• 尽最大可能重用已经建立的 TCP 连接。
	
