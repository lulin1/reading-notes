# chapter 1 延迟与带宽

本章主要介绍对所有网络通信都有决定性影响的两个方面：延迟和带宽

	• 延迟

	分组从信息源发送到目的地所需的时间。

	• 带宽

	逻辑或物理通信路径最大的吞吐量。

![1-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/1-1.jpg)

延迟是消息（message）或分组（packet）从起点到终点经历的时间。这个定义简单明了，但却掩盖了很多有用的信息。事实上，任何系统都有很多因素可能影响传送消息
的时间。

下面看看路由器这个负责在客户端和服务器之间转发消息的设备，会牵涉哪些影响延迟的因素。
	
 	• 传播延迟
  
	消息从发送端到接收端需要的时间，是信号传播距离和速度的函数
  
	• 传输延迟
  
	把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数
  
	• 处理延迟
  
	处理分组首部、检查位错误及确定分组目标所需的时间
  
	• 排队延迟
  
	到来的分组排队等待处理的时间
  

以上延迟的时间总和，就是客户端到服务器的总延迟时间。传播时间取决于距离和信号通过的媒介，另外传播速度通常不超过光速。而传输延迟由传输链路的速率决
定，与客户端到服务器的距离无关。举个例子，假设有一个 10 MB 的文件，分别通过两个链路传输，一个 1 Mbit/s，另一个 100 Mbit/s。在 1 Mbit/s 的链路上，需要花10 s，而在 100 Mbit/s 的链路上，只需 0.1 s。


# chapter 2 TCP的构成

因特网有两个核心协议：IP 和 TCP。

	IP，即 Internet Protocol（因特网协议），负责联网主机之间的路由选择和寻址；

	TCP，即 Transmission Control Protocol（传输控制协议），负责在不可靠的传输信道之上提供可靠的抽象层。

TCP/IP 也常被称为“因特网协议套件”（Internet Protocol Suite），是由 Vint Cerf 和 Bob Khan 在他们1974 的论文“A Protocol for Packet Network Intercommunication”（一种分组网络互通的协议）中首次提出来的。

## 2.1 三次握手

![2-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-1.jpg)

	• SYN
	
	客户端选择一个随机序列号 x，并发送一个 SYN 分组，其中可能还包括其他 TCP标志和选项。
	
	• SYN ACK
	
	服务器给 x 加 1，并选择自己的一个随机序列号 y，追加自己的标志和选项，然后返回响应。
	
	• ACK
	
	客户端给 x 和 y 加 1 并发送握手期间的最后一个 ACK 分组。
	
	
三次握手完成后，客户端与服务器之间就可以通信了。客户端可以在发送 ACK 分组之后立即发送数据，而服务器必须等接收到 ACK 分组之后才能发送数据。这个启动通信的过程适用于所有 TCP 连接，因此对所有使用 TCP 的应用具有非常大的性能影响，因为每次传输应用数据之前，都必须经历一次完整的往返。	

三次握手带来的延迟使得每创建一个新 TCP 连接都要付出很大代价。而这也决定了提高 TCP 应用性能的关键，在于想办法重用连接。

## 2.2　拥塞预防及控制

TCP 加入了很多机制，以便控制双向发送数据的速度，比如： 流量控制、　拥塞控制　和　拥塞预防机制。

### 2.2.1  流量控制

 流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP 连接的每一方都要通告（图 2-2）自己的接收窗口（rwnd），其中包含能够保存数据的缓冲区空间大小信息。
 
 ![2-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-2.jpg)
 
 第一次建立连接时，两端都会使用自身系统的默认设置来发送 rwnd。
 
 不管怎样，如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。这个过程贯穿于每个 TCP 连接的整个生命周期：每个 ACK 分组都会携带相应的最新 rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力。
 
 ### 2.2.2 慢启动
 
 	接收窗口大小（rwnd）
	
	拥塞窗口大小（cwnd）
	
首先，三次握手，而且在此期间双方各自通过 ACK 分组通告自己的接收窗口（rwnd）大小（图 2-2）。在发送完最后一次 ACK 分组后，就可以交换应用数据了。

新 TCP 连接传输的最大数据量取 rwnd 和 cwnd 中的最小值，而服务器实际上可以向客户端发送 4 个 TCP 段，然后就必须停下来等待确认。此后，每收到一个 ACK，慢启动算法就会告诉服务器可以将它的 cwnd 窗口增加 1 个 TCP 段。每次收到 ACK后，都可以多发送两个新的分组。TCP 连接的这个阶段通常被称为“指数增长”阶段（图2-3），因为客户端和服务器都在向两者之间网络路径的有效带宽迅速靠拢。

 ![2-3.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-3.jpg)

 为什么知道有个慢启动对我们构建浏览器应用这么重要呢?因为包括 HTTP 在内的很多应用层协议都运行在 TCP 之上,无论带宽多大,每个 TCP 连接都必须经过慢启动阶段。换句话说,我们不可能一上来就完全利用连接的最大带宽!相反,我们要从一个相对较小的拥塞窗口开始,每次往返都令其翻倍(指数式增长)。而达到某个目标吞吐量所需的时间,就是客户端与服务器之间的往返时间和初始拥塞窗口大小的函数(公式 2-1)。
 
 ![formula2-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/formula2-1.jpg)

 
要达到客户端与服务器之间 64 KB 的吞吐量,需要 4 次往返(图 2-4),几百 ms 的延迟!至于客户端与服务器之间实际的连接速率是不是在 Mbit/s 级别,丝毫不影响这个结果。这就是慢启动。

 ![2-4.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/2-4.jpg)
 
 为减少增长到拥塞窗口的时间,可以减少客户端与服务器之间的往返时间。比如,把服务器部署到地理上靠近客户端的地方。要么,就把初始拥塞窗口大小增加到RFC 9828 规定的 10 段。

慢启动导致客户端与服务器之间经过几百 ms 才能达到接近最大速度的问题,对于大型流式下载服务的影响倒不显著,因为慢启动的时间可以分摊到整个传输周期内消化掉。

可是,对于很多 HTTP 连接,特别是一些短暂、突发的连接而言,常常会出现还没有达到最大窗口请求就被终止的情况。换句话说,很多 Web 应用的性能经常受到服务器与客户端之间往返时间的制约。因为慢启动限制了可用的吞吐量,而这对于小文件传输非常不利。


### 2.2.3 拥塞预防

认识到 TCP 调节性能 主要依赖丢包反馈机制非常重要。换句话说,这不是一个假设命题,而是一个具体何时发生的命题。慢启动以保守的窗口初始化连接,随后的每次往返都会成倍提高传输的数据量,直到超过接收端的流量控制窗口,即系统配置的拥塞阈值(ssthresh)窗口,或者有分组丢失为止,此时拥塞预防算法介入。

拥塞预防算法把丢包作为网络拥塞的标志,即路径中某个连接或路由器已经拥堵了,以至于必须采取删包措施。因此,必须调整窗口大小,以避免造成更多的包丢失,从而保证网络畅通。

重置拥塞窗口后,拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。


## 2.3 带宽延迟积

TCP 内置的　拥塞控制　和　预防机制　对性能还有另一个重要影响:　发送端和接收端理想的窗口大小,一定会因往返时间及目标传输速率而变化。

无论发送端发送的数据还是接收端接收的数据超过了未确认的最大数据量,都必须停下来等待另一方 ACK 确认某些分组才能继续。要等待多长时间呢?取决于往返时间!
	
	BDP ( Bandwidth-delay product ,带宽延迟积)
	
	数据链路的容量与其端到端延迟的乘积。这个结果就是任意时刻处于在途未确认状态的最大数据量。


## 2.4 队首阻塞

TCP 在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发,以及保证网络最高效率的流量控制、拥塞控制和预防机制,让TCP 成为大多数网络应用中最常见的传输协议。

每个 TCP 分组都会带着一个唯一的序列号被发出,而所有分组必须按顺序传送到接收端(图 2-8 )。如果中途有一个分组没能到达接收端,那么后续分组必须保存在接收端的 TCP 缓冲区,等待丢失的分组重发并到达接收端。这一切都发生在 TCP 层,应用程序对 TCP 重发和缓冲区中排队的分组一无所知,必须等待分组全部到达才能访问数据。在此之前,应用程序只能在通过 套接字 读数据时感觉到延迟交付。这种效应称为 TCP 的队首(HOL,Head of Line)阻塞。

队首阻塞造成的延迟可以让我们的应用程序不用关心分组重排和重组,从而让代码保持简洁。然而,代码简洁也要付出代价,那就是分组到达时间会存在无法预知的 延迟变化。这个时间变化通常被称为抖动,也是影响应用程序性能的一个主要因素。

无需按序交付数据或能够处理分组丢失的应用程序,以及对延迟或抖动要求很高的应用程序,最好选择 UDP 等协议。虽然 TCP 很流行,但它并不是唯一的选择,而且在某些情况下也不是最佳的选择。特别是按序交付和可靠交付有时候并不必要,反而会导致额外的延迟,对性能造成负面影响。


## 2.5 针对TCP的优化建议

TCP 是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此,优化 TCP 的最佳途径就是 调整它感知当前网络状况的方式,根据它之上或之下的抽象层的类型和需求来改变它的行为。

	尽管如此,而且每个算法和反馈机制的具体细节可能会继续发展,但核心原理以及它们的影响是不变的:
	
	• TCP 三次握手增加了整整一次往返时间;
	
	• TCP 慢启动将被应用到每个新连接;
	
	• TCP 流量及拥塞控制会影响所有连接的吞吐量;
	
	• TCP 的吞吐量由当前拥塞窗口大小控制。

尽管带宽不断增长,但延迟依旧受限于光速,而且已经限定在了其最大值的一个很小的常数因子之内。大多数情况下,TCP 的瓶颈都是 延迟,而非 带宽。

调优 TCP 性能可以让服务器和客户端之间达到最大吞吐量和最小延迟。

### 2.5.1  服务器配置调优

一句话,让你的服务器跟上时代是优化发送端和接收端 TCP 栈的首要措施。
	
### 2.5.2  应用程序行为调优

	• 再快也快不过什么也不用发送,能少发就少发。
	
	• 我们不能让数据传输得更快,但可以让它们传输的距离更短。
	
	• 重用 TCP 连接是提升性能的关键。
	
	
### 2.5.3  性能检查清单

	• 把服务器内核升级到最新版本(Linux:3.2+);
	
	• 确保 cwnd 大小为 10;
	
	• 禁用空闲后的慢启动;
	
	• 确保启动窗口缩放;
	
	• 减少传输冗余数据;
	
	• 压缩要传输的数据;
	
	• 把服务器放到离用户近的地方以减少往返时间;
	
	• 尽最大可能重用已经建立的 TCP 连接。
	

# chapter 3 UDP的构成

1980 年 8 月,紧随 TCP/IP 之后,UDP(User Datagram Protocol,用户数据报协议)被 John Postel 加入了核心网络协议套件 。当时,正值 TCP 和 IP 规范分立为两个单独的 RFC。这个时间点非常重要,稍后我们会看到,UDP 的主要功能和亮点并不在于它引入了什么特性,而在于它忽略的那些特性。

数据报(datagram)和分组(packet)是两个经常被人混用的词,实际上它们还是有区别的。分组可以用来指代任何格式化的数据块,而数据报则通常只用来描述那些通过不可靠的服务传输的分组,既不保证送达,也不发送失败通知。正因为如此,很多场合下人们都把 UDP 中 User(用户)的 U,改成 Unreliable(不可靠)的 U,于是 UDP 就成了“不可靠数据报协议”(Unreliable Datagram Protocol)。这也是为什么把 UDP 分组称为数据报更为恰当的原因。

HTTP 并未规定要使用 TCP,但现实中所有 HTTP 实现(以及构建于其上的所有服务)都使用 TCP。WebRTC 着眼于在浏览器中通过 UDP 实现原生的语音和视频实时通信,以及其他形式的 P2P(Peer-to-Peer,端到端)通信。正是因为 WebRTC 的出现,UDP 作为浏览器中重要传输机制的地位才得以突显,而且还有了浏览器 API！


## 3.1 无协议服务

要理解为什么 UDP 被人称作“无协议”,必须从作为 TCP 和 UDP 下一层的 IP 协议说起。

 ![3-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/3-1.jpg)
 
UDP 协议会用自己的分组结构(图 3-2)封装用户消息,它只增加了 4 个字段: 源端口、目标端口、分组长度和校验和。这样,当 IP 把分组送达目标主机时,该主机
能够拆开 UDP 分组,根据目标端口找到目标应用程序,然后再把消息发送过去。仅此而已。

 ![3-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/3-2.jpg)
 
事实上,UDP 数据报中的源端口和校验和字段都是可选的。IP 分组的首部也有校验和,应用程序可以忽略 UDP 校验和。也就是说,所有错误检测和错误纠正工作都可
以委托给上层的应用程序。说到底,UDP 仅仅是在 IP 层之上通过嵌入应用程序的源端口和目标端口,提供了一个“应用程序多路复用”机制。明白了这一点,就可以总结一下 UDP 的无服务是怎么回事了。

	• 不保证消息交付
	不确认,不重传,无超时。
		
	• 不保证交付顺序
	不设置包序号,不重排,不会发生队首阻塞。
	
	• 不跟踪连接状态
	不必建立连接或重启状态机。
	
	• 不需要拥塞控制
	不内置客户端或网络反馈机制。
		
UDP 数据报有明确的限制:数据报必须封装在 IP 分组中,应用程序必须读取完整的消息。换句话说,数据报不能分片。

UDP 是一个简单、无状态的协议,适合作为其他上层应用协议的辅助。


## 3.2   UDP 与网络地址转换器

IPv4 地址只有 32 位长,因而最多只能提供 42.9 亿个唯一 IP 地址。1994 年,作为解决 IPv4 地址即将耗尽的一个临时性方案,IP 网络地址转换(NAT,Network Address Translator) 规范出台了,这就是 RFC 1631。


### 3.2.1  连接状态超时

NAT 转换的问题(至少对于 UDP 而言)在于必须维护一份精确的路由表才能保证数据转发。NAT 设备依赖连接状态,而 UDP 没有状态。这种根本上的错配是很多UDP 数据报传输问题的总根源。况且,客户端前面有很多个 NAT 设备的情况也不鲜见,问题由此进一步恶化了。

UDP 呢,没有握手,没有连接终止,实际根本没有可监控的连接状态机。

更糟糕的是,NAT 设备还被赋予了删除转换记录的责任,但由于 UDP 没有连接终止确认环节,任何一端随时都可以停止传输数据报,而不必发送通告。为解决这个问题,UDP 路由记录会定时过期。定时多长?没有规定,完全取决于转换器的制造商、型号、版本和配置。因此,对于较长时间的 UDP 通信,有一个事实上的最佳做法,即引入一个双向 keep-alive 分组,周期性地重置传输路径上所有 NAT 设备中转换记录的计时器。

 ![3-4.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/3-4.jpg)
 
 
### 3.2.3   STUN、TURN 与 ICE


## 3.3  针对 UDP 的优化建议

UDP 是一个简单常用的协议,经常用于引导其他传输协议。事实上,UDP 的特色在于它所省略的那些功能:连接状态、握手、重发、重组、重排、拥塞控制、拥塞预防、流量控制,甚至可选的错误检测,统统没有。这个面向消息的最简单的传输层在提供灵活性的同时,也给实现者带来了麻烦。你的应用程序很可能需要从头实现上述几个或者大部分功能,而且每项功能都必须保证与网络中的其他主机和协议和谐共存。


# chapter 4 传输层安全(TLS)

SSL(Secure Sockets Layer,安全套接字层)协议最初是网景公司为了保障网上交易安全而开发的,该协议通过加密来保护客户个人资料,通过认证和完整性检查来
确保交易安全。为达到这个目标,SSL 协议在直接位于 TCP 上一层的应用层被实现(图 4-1)。SSL 不会影响上层协议(如 HTTP、电子邮件、即时通讯),但能够保证
上层协议的网络通信安全。

 ![4-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-1.jpg)

	IETF 后 来 在 标 准 化 SSL 协 议 时, 将 其 改 名 为 Transport Layer Security(TLS,传输层安全)。很多人会混用 TLS 和 SSL,但严格来讲它们并不相同,因为它们指代的协议版本不同。
	
	
SSL 2.0 是该协议第一个公开发布的版本,但由于存在很多安全缺陷很快就被 SSL3.0 取代。鉴于 SSL 协议是网景公司专有的,IETF 成立了一个小组负责标准化该协
议,后来就有了 RFC 2246,即 TLS 1.0,也就是 SSL 3.0 的升级版。

## 4.1  加密 、 身份验证与完整性

TLS 协议的目标是为在它之上运行的应用提供三个基本服务:加密、身份验证和数据完整性。从技术角度讲,并不是所有情况下都要同时使用这三个服务。比如,可
以接受证书但不验证其真实性,而前提是你非常清楚这样做有什么安全风险且有防范措施。实践中,安全的 Web 应用都会利用这三个服务。

	• 加密
	  混淆数据的机制
	  
	• 身份验证
	  验证身份标识有效性的机制
	  
	• 完整性
	  消息是否被篡改或伪造的机制

为了建立加密的安全数据通道,连接双方必须就加密数据的密钥套件和密钥协商一致 。TLS 协议规定了一套严密的握手程序用于交换这些信息,相关内容将在 4.2 节
“TLS 握手”中介绍。握手机制中设计最巧妙的地方,就是其使用的公钥密码系统(也称“非对称密钥加密”),这套系统可以让通信双方不必事先“认识”即可商定共享的安全密钥,而且协商过程还是通过非加密通道完成的。

 ![4-other-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-other-1.jpg)
 ![4-other-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-other-2.jpg)


## 4.2 TLS握手

 ![4-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-2.jpg)
 
 	• 0 ms:TLS 在可靠的传输层(TCP)之上运行,这意味着首先必须完成 TCP 的“三次握手”,即一次完整的往返。
	
	• 56 ms:TCP 连接建立之后,客户端再以纯文本形式发送一些规格说明,比如它所运行的 TLS 协议的版本、它所支持的加密套件列表,以及它支持或希望使用		的另外一些 TLS 选项。
	
	• 84 ms:然后,服务器取得 TLS 协议版本以备将来通信使用,从客户端提供的加密套件列表中选择一个,再附上自己的证书,将响应发送回客户端。作为可选	      项,服务器也可以发送一个请求,要求客户端提供证书以及其他 TLS 扩展参数。
	
	• 112 ms:假设两端经过协商确定了共同的版本和加密套件,客户端也高高兴兴地把自己的证书提供给了服务器。然后,客户端会生成一个新的对称密钥,用服务	    器的公钥来加密,加密后发送给服务器,告诉服务器可以开始加密通信了。到目前为止,除了用服务器公钥加密的新对称密钥之外,所有数据都以明文形式发送。
	
	• 140 ms:最后,服务器解密出客户端发来的对称密钥,通过验证消息的 MAC 检测消息完整性,再返回给客户端一个加密的“Finished”消息。
	
	• 168 ms:客户端用它之前生成的对称密钥解密这条消息,验证 MAC,如果一切顺利,则建立信道并开始发送应用数据。


总之,尽管我们的 Web 应用不一定参与上述过程,但最重要的是知道每一个 TLS连接在 TCP 握手基础上最多还需要两次额外的往返。这些都会增加实际交换数据之前的等待时间!如果考虑不周,通过 TLS 交付数据很可能会引入几百甚至几千ms的网络延迟。


### 4.2.1 应用层协议协商(ALPN)

每个端口都必须得到认可,而防火墙及其他中间设备通常只允许在 80 和 443 端口上通信。

80 端口是为 HTTP 保留的,而 HTTP 规范还专门为协商协议规定了一个 Upgrade 首部。可是,使用 Upgrade 需要一次额外的往返时间,且由于很多中间设备的存在,协商结果也不可靠。


顾名思义,应用层协议协商(ALPN,Application Layer Protocol Negotiation)作为TLS 扩展,让我们能在 TLS 握手的同时协商应用协议(图 4-2),从而省掉了 HTTP的 Upgrade 机制所需的额外往返时间。具体来说,整个过程分如下几步:

	•  客户端在 ClientHello 消息中追加一个新的 ProtocolNameList 字段,包含自己支持的应用协议;
	   
	•  服务器检查 ProtocolNameList 字段,并在 ServerHello 消息中以 ProtocolName 字段返回选中的协议。

服务器可以从中选择一个协议名,否则如果不支持其中的任何协议,则断开连接。只要 TLS 握手完成、建立了加密信道并就应用协议达成一致,客户端与服务器就可
以立即通信。


### 4.2.2  服务器名称指示 (SNI)

网络上可以建立 TCP 连接的任意两端都可以建立加密 TLS 信道,客户端只需知道另一端的 IP 地址即可建立连接并进行 TLS 握手。然而,如果服务器想在一个 IP 地
址为多个站点提供服务,而每个站点都拥有自己的 TLS 证书,那怎么办?这问题看似有点怪,但其实一点都不怪。

为了解决这个问题,SNI(Server Name Indication,服务器名称指示)扩展被引入TLS 协议,该扩展允许客户端在握手之初就指明要连接的主机名。 Web 服务器可以
检查 SNI 主机名,选择适当的证书,继续完成握手。


## 4.3   TLS 会话恢复

完整 TLS 握手会带来额外的延迟和计算量,从而给所有依赖安全通信的应用造成严重的性能损失。为了挽回某些损失,TLS 提供了恢复功能,即在多个连接间共享协商后的安全密钥。

 ### 4.3.1  会话标识符

最早的“会话标识符”(Session Identifier,RFC 5246)机制是在 SSL 2.0 中引入的,支持服务器创建 32 字节的会话标识符,并在上一节我们讨论的完整的 TLS 协商期间作为其“ServerHello”消息的一部分发送。

在内部,服务器会为每个客户端保存一个会话 ID 和协商后的会话参数。相应地,客户端也可以保存会话 ID 信息,并将该 ID 包含在后续会话的“ClientHello”消息中,从而告诉服务器自己还记着上次握手协商后的加密套件和密钥呢,这些都可以重用。假设客户端和服务器都可以在自己的缓存中找到共享的会话 ID 参数,那么就可以进行简短握手(图 4-3)。否则,就要重新启动一次全新的会话协商,生成新的会话 ID。

借助 会话标识符 可以节省一次往返,还可以省掉用于协商共享加密密钥的公钥加密计算。由于重用了之前协商过的会话数据,就可以迅速建立一个加密连接,而且同样安全。

	实际应用中,大多数 Web 应用会尝试与同一个主机建立多个连接,以便并行取得资源。在这种情况下,会话恢复就成为减少延迟及两端计算量的必
	备优化手段。
	
	大多数现代浏览器在打开到相同服务器的新连接之前,都会有意等待第一个 TLS 连接完成。这样,后续的 TLS 连接就可以重用第一个 SSL 会话,
	从而避免重新握手造成的损失。

 ![4-3.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-3.jpg)

由于每个打开的 TLS 连接都要占用内存,因此需要一套会话 ID 缓存和清除策略,


### 4.3.2 会话记录单

为了解决上述服务器端部署 TLS 会话缓存的问题,“会话记录单”(Session Ticket,RFC 5077)机制出台了,该机制不用服务器保存每个客户端的会话状态。相反,如
果客户端表明其支持会话记录单,则服务器可以在完整 TLS 握手的最后一次交换中添加一条“新会话记录单”(New Session Ticket)记录,包含只有服务器知道的安全密钥加密过的所有会话数据。

然后,客户端将这个会话记录单保存起来,在后续会话的 ClientHello 消息中,可以将其包含在 SessionTicket 扩展中。这样,所有会话数据只保存在客户端,而由于
数据被加密过,且密钥只有服务器知道,因此仍然是安全的。

我们这里所说的会话标识符和会话记录单机制,也经常被人称为“会话缓存”或“无状态恢复”机制。无状态恢复机制的优点主要是消除了服务器端的缓存负担,通过要求客户端在与服务器建立新连接时提供会话记录单简化了部署(除非记录单过期)。


### 4.4  信任链与证书颁发机构

身份验证是建立每个 TLS 连接必不可少的部分。毕竟,加密信道两端可以是任何机器,包括攻击者的机器。

我的浏览器信任谁?我在使用浏览器的时候信任谁?这个问题至少有三个答案。

	• 手工指定证书
	所有浏览器和操作系统都提供了一种手工导入信任证书的机制。至于如何获得证书和验证完整性则完全由你自己来定。

	• 证书颁发机构
	CA(Certificate Authority,证书颁发机构)是被证书接受者(拥有者)和依赖证书的一方共同信任的第三方。

	• 浏览器和操作系统
	每个操作系统和大多数浏览器都会内置一个知名证书颁发机构的名单。因此,你也会信任操作系统及浏览器提供商提供和维护的可信任机构。
			
			
实践中,保存并手工验证每个网站的密钥是不可行的(当然,如果你愿意,也可以)。现实中最常见的方案就是让证书颁发机构替我们做这件事(图 4-5):浏览器指定可信任的证书颁发机构(根 CA),然后验证他们签署的每个站点的责任就转移到了他们头上,他们会审计和验证这些站点的证书没有被滥用或冒充。持有 CA 证书的站点的安全性如果遭到破坏,那撤销该证书也是证书颁发机构的责任。

 ![4-5.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-5.jpg)

所有浏览器都允许用户检视自己安全连接的信任链,常见的访问入口就是地址栏头儿上的锁图标,点击即可查看(图 4-6)。

	• igvita.com 证书由 StartCom Class 1 Primary Intermediate Server 签发。
	
	• StartCom Class 1 Primary Intermediate Server 证书由 StartCom Certification Authority 签发。
	
	• StartCom Certification Authority 被认为是根证书颁发机构。

 ![4-6.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-6.jpg)

整 个 链 条 的“ 信 任 依 据 ” 是 根 证 书 颁 发 机 构, 在 这 里 就 是 StartCom CertificationAuthority。每个浏览器都会内置一个可信任的证书颁发机构(根机构)的名单,在此浏览器相信而且能够验证 StartCom 根证书。



## 4.5  证书撤销

证书本身会包含如何检测其是否过期的指令(图 4-7)。为确保信任链不被破坏,通信的任何一端都可以根据嵌入的指令和签名检查链条中每个证书的状态。

### 4.5.1  证书撤销名单 (CRL)

CRL(Certificate Revocation List,证书撤销名单)是 RFC 5280 规定的一种检查所有证书状态的简单机制:每个证书颁发机构维护并定期发布已撤销证书的序列号名单。这样,任何想验证证书的人都可以下载撤销名单,检查相应证书是否榜上有名。如果有,说明证书已经被撤销了。

### 4.5.2  在线证书状态协议 (OCSP)

为 解 决 CRL 机 制 的 上 述 问 题,RFC 2560 定 义 了 OCSP(Online Certificate Status Protocol,在线证书状态协议),提供了一种实时检查证书状态的机制。与 CRL 包含被撤销证书的序列号不同,OCSP 支持验证端直接查询证书数据库中的序列号,从而验证证书链是否有效。总之,OCSP 占用带宽更少,支持实时验证。

	实践中,CRL 和 OCSP 机制是互补存在的,大多数证书既提供指令也支持查询。
	
	
### 4.6   TLS 记录协议

与位于其下的 IP 或 TCP 层没有什么不同,TLS 会话中交换的所有数据同样使用规格明确的协议进行分帧(图 4-8)。TLS 记录协议负责识别不同的消息类型(握手、
警告或数据,通过“内容类型”字段),以及每条消息的安全和完整性验证。

 ![4-8.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-8.jpg)
 
 交付应用数据的典型流程如下：
 
	• TLS记录协议  接收应用数据。
	
	• 接收到的数据被切分为块:最大为每条记录 2 14 字节,即 16 KB。
	
	• 压缩应用数据(可选)。
	
	• 添加 MAC(Message Authentication Code)或 HMAC。
	
	• 使用商定的加密套件加密数据。

以上几步完成后,加密数据就会被交给 TCP 层传输。接收端的流程相同,顺序相反:使用商定的加密套件解密数据、验证 MAC、提取并把数据转交给上层的应用。

同样,值得庆幸的是以上过程都由 TLS 层帮我们处理, 而且对大多数应用都是完全透明的。不过,记录协议也带来了一些  重要的限制,务必要注意:

	• TLS 记录最大为 16 KB;
	
	• 每条记录包含 5 字节的首部、 MAC(在 SSL 3.0、 TLS 1.0、 TLS 1.1 中最多 20 字节,在 TLS 1.2 中最多 32 字节),如果使用块加密则还有填充;
	
	• 必须接收到整条记录才能开始解密和验证。
	
有可能的话,应该自主选择记录大小,这也是一项重要的优化。小记录会因记录分帧而招致较大开销,大记录在被 TLS 层处理并交付应用之前,必须通过 TCP 传输和重新组装。


## 4.7  针对 TLS 的优化建议

### 4.7.1  计算成本

### 4.7.2  尽早完成 ( 握手 )

换句话说,只要能省掉握手,就应该省掉。如果必须握手,那么还有一个可能的技巧:尽早完成。


第 1 章讨论过,我们不能指望延迟在将来能下降多少,因为光电信号的传输速度已经是光速的一个非常小的常数因子了。不能让分组传播更快  ,但可以缩短传播距离! 尽早完成就是这么一个技巧,即通过把服务器放到离用户更近的地方(图 4-9 ),让客户端与服务器之间往返延迟最少。

 ![4-9.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/4-9.jpg)

虽然 CDN 最常用于在全球优化分发静态资源,但其优点并不止于此。距离客户端更近的服务器还可以缩短 TLS 会话,因为 TCP 和 TLS 握手的对象都是近处的服务
器,所以建立连接的总延迟就会显著减少。相应地,本地代理服务器则可以与原始服务器建立一批长期的安全连接,全权代理请求与响应。

简言之,把服务器放到接近客户端的地方能够节约 TCP 和 TLS 握手的时间!


### 4.7.3  会话缓存与无状态恢复

无论什么情况下,在接近用户的地方终止连接都有助于减少延迟,但有延迟终归快不过没有延迟。启用 TLS 会话缓存和无状态恢复可以完全消除“回头客”的往返时间。



### 4.7.4  TLS 记录大小

小记录会造成浪费,大记录会导致延迟。  因此,记录到底多大合适没有唯一“正确”的答案。不过对于在浏览器中运行的 Web 应用来说,倒是有一个值得推荐的做法:  每个 TCP 分组恰好封装一个 TLS 记录,而 TLS 记录大小恰好占满 TCP 分配的MSS(Maximum Segment Size,最大段大小)。换句话说,一方面不要让 TLS 记录 分成多个 TCP 分组,另一方面又要尽量在一条记录中多发送数据。以下数据可作为确定最优 TLS 记录大小的参考:

	• IPv4 帧需要 20 字节,IPv6 需要 40 字节;
	
	• TCP 帧需要 20 字节;
	
	• TCP 选项需要 40 字节(时间戳、SACK 等)。

### 4.7.5  TLS 压缩

虽然不能使用 TLS 压缩,但应该使用服务器的 Gzip 设置压缩所有文本资源,同时对图像、视频、音频等媒体采用最合适的压缩格式。

### 4.7.6  证书链的长度

### 4.7.7  OCSP 封套

### 4.7.8   HTTP 严格传输安全 (HSTS)

HTTP 严格传输安全(HSTS,Strict Transport Security)是一种安全策略机制,它能让服 务 器 通 过 简 单 的 HTTP 首 部( 如 Strict-Transport-Security: max-age=31536000 )对适用的浏览器声明访问规则。

事实上,HSTS 会把原始服务器转换为只处理 HTTPS 的目标服务器,从而确保应用不会因各种主动或被动攻击给用户造成损失。从性能角度说,HSTS 通过把责任转移到客户端,让客户端自动把所有链接重写为 HTTPS,消除了从 HTTP 到 HTTPS的重定向损失。



## 4.8  性能检查清单

	• 要最大限制提升 TCP 性能,请参考 2.5 节“针对 TCP 的优化建议”;
	
	• 把 TLS 库升级到最新版本,在此基础上构建(或重新构建)服务器;
	
	• 启用并配置会话缓存和无状态恢复;
	
	• 监控会话缓存的使用情况并作出相应调整;
	
	• 在接近用户的地方完成 TLS 会话,尽量减少往返延迟;
	
	• 配置 TLS 记录大小,使其恰好能封装在一个 TCP 段内;
	
	• 确保证书链不会超过拥塞窗口的大小;
	
	• 从信任链中去掉不必要的证书,减少链条层次;
	
	• 禁用服务器的 TLS 压缩功能;
	
	• 启用服务器对 SNI 的支持;
	
	• 启用服务器的 OCSP 封套功能;
	
	• 追加 HTTP 严格传输安全首部。
	
	
## 4.9  测试与验证
