# chapter 9 HTTP简史

## 9.1 HTTP 0.9: 只有一行的协议

简单总结一下 HTTP 0.9 的功能:

	• 客户端 / 服务器、请求 / 响应协议;
  
	• ASCII 协议,运行于 TCP/IP 链接之上;
  
	• 设计用来传输超文本文档(HTML);
  
	• 服务器与客户端之间的连接在每次请求之后都会关闭。


## 9.2 HTTP 1.0: 迅速发展及参考性 RFC

该协议的关键变化:

	• 请求可以由于多行首部字段构成;
  
	• 响应对象前面添加了一个响应状态行;
  
	• 响应对象也有自己的由换行符分隔的首部字段;
  
	• 响应对象不局限于超文本;
  
	• 服务器与客户端之间的连接在每次请求之后都会关闭。
	
HTTP 1.0 的优化策略非常简单,就一句话:升级到 HTTP 1.1。完了!


## 9.3 HTTP 1.1: 互联网标准

HTTP 1.1 标准厘清了之前版本中很多有歧义的地方,而且还加入了很多重要的性能优化: 持久连接、分块编码传输、字节范围请求、增强的缓存机制、传输编码及请求管道。

![9-other-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/9-other-1.jpg)

![9-other-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/9-other-2.jpg)

最明显的差别是这里发送了两次对象请求,一次请求 HTML 页面,一次请求图片,这两次请求都是通过一个连接完成的。这个连接是持久的,因而可以重用 TCP 连接对同一主机发送多次请求,从而实现更快的用户体验。

为终止持久连接,客户端的第二次请求通过 Connection 首部,向服务器明确发送了关闭令牌。类似地,服务器也可以在响应完成后,通知客户端自己想要关闭当前TCP 连接。从技术角度讲,不发送这个令牌,任何一端也可以终止 TCP 连接。但为
确保更好地重用连接,客户端和服务器都应该尽可能提供这个信息。

	HTTP 1.1 改变了 HTTP 协议的语义,默认使用持久连接。换句话说,除非明确告知(通过 Connection: close 首部),
	否则服务器默认会保持连接打开。
  
  
	不过,这个功能也反向移植到了 HTTP 1.0,可以通过 Connection: Keep-Alive 首部来启用。
	实际上,如果你使用的是 HTTP 1.1,从技术上说不需要 Connection: Keep-Alive 首部,但很多客户端还是选择加上它。


## 9.4 HTTP 2.0: 改进传输性能

HTTP 2.0 的主要目标是改进传输性能,实现低延迟和高吞吐量。



# chapter 10 web性能要点

在任何复杂的系统中,性能优化的很大一部分工作就是把不同层之间的交互过程分解开来,弄清楚每一层次交互的约束和限制。到目前为止,我们已经比较详细地分析了一些个别网络组件(不同的物理交付方式和传输协议)。现在,我们把目光转向更宏观的 Web 性能优化:

	• 延迟和带宽对 Web 性能的影响;
	
	• 传输协议(TCP)对 HTTP 的限制;
	
	• HTTP 协议自身的功能和缺陷;
	
	• Web 应用的发展趋势及性能需求;
	
	• 浏览器局限性和优化思路。


## 10.1  超文本 、 网页和 Web 应用

结果,页面加载时间,这个一直以来衡量 Web 性能的事实标准,作为一个性能基础也越来越显得不够了。我们不再是构建网页,而是在构建一个动态、交互的 Web 应用。除了测量每个资源及整个页面的加载时间(PLT),还要回答有关应用的如下几个问题:

	• 应用加载过程中的里程碑是什么?
	
	• 用户第一次交互的时机何在? 
	
	• 什么交互应该吸引用户参与?
	
	• 每个用户的参与及转化率如何?
	
	
性能好坏及优化策略成功与否,与你定义应用的特定基准和条件,并反复测试的效果直接相关。

![10-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/10-1.jpg)

![10-1-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/10-1-2.jpg)



## 10.2 剖析现代 Web 应用

![10-2.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/10-2.jpg)


### 10.2.1  速度 、 性能与用户期望

![table-10-1.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/table-10-1.jpg)

### 10.2.2  分析资源瀑布

首先,必须知道每一个 HTTP 请求都由很多独立的阶段构成(图 10-3):DNS 解析、TCP 连 接 握 手、TLS 协 商( 必 要 时 )、 发 送 HTTP 请 求, 然 后 下 载 内 容。

![10-4.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/10-4.jpg)


## 10.3  性能来源 : 计算 、 渲染和网络访问

Web 应用的执行主要涉及三个任务:取得资源、页面布局和渲染、JavaScript 执行。其中,渲染和脚本执行在一个线程上交错进行,不可能并发修改生成的 DOM。


### 10.3.1  更多带宽其实不 ( 太 ) 重要


### 10.3.2  延迟是性能瓶颈

![10-6.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/10-6.jpg)



## 10.4  人造和真实用户性能度量

宽泛地说,在受控度量环境下完成的任何测试都可称为人造测试。首先,本地构建过程运行性能套件,针对基础设施加载测试,或者针对一组分散在各地的监控服务器加载测试,这些服务器定时运行脚本并记录输出。这些测试中的任何一个都可能测试不同的基础设施(如应用服务器的吞吐量、数据库性能、DNS 时间,等等),并作为稳定的基准辅助检测性能衰退或聚焦于系统的某个特定组件。


只要配置得当,人造测试就可以提供一个受控且可重现的性能测试环境。而这个环境非常适合发现和修复性能问题,确保用户体验。提示:确定一个关键的性能指标,并为它们分别设定一个“预算额度”,纳入人造测试计划。一旦哪个指标超出“预算”,马上拉响警报!


上述这些方面,加之其他一些类似情况,意味着除了人造测试,我们必须通过真实用户度量(RUM,Real-User Measurement)来获取用户使用我们应用的真实性能数据,从而确保性能度量的有效性。有一个好消息,W3C Web Performance Working Group 通过引入 Navigation Timing API(图 10-7)为我们做真实用户测试提供了便利,这个 API 目前已得到很多现代桌面和移动浏览器的支持。

![10-7.jpg](https://github.com/lulin1/reading-notes/blob/master/HighPerformanceBrowserNetworking/pics/10-7.jpg)

Navigation Timing 的真正好处是它提供了以前无法访问的数据,比如 DNS 和 TCP连接时间,而且精确度极高(微秒级时间戳)。要获得这些数据,可以在浏览器中访
问标准的 performance.timing 对象。实际上,收集这些数据的过程很简单:加载页面,从用户浏览器中取得相应的计时对象,然后将其传回分析服务器!通过观察这些数据,就可以知道用户使用我们应用时的真实性能,发现不同硬件和不同网络连接导致的差异。



## 10.5  针对浏览器的优化建议

可行的优化手段会因浏览器而异,但从核心优化策略来说,可以宽泛地分为两类。

	• 基于文档的优化
		熟悉网络协议,了解文档、CSS 和 JavaScript 解析管道,发现和优先安排关键网
		络资源,尽早分派请求并取得页面,使其尽快达到可交互的状态。主要方法是优
		先获取资源、提前解析等。
		
	• 推测性优化
		浏览器可以学习用户的导航模式,执行推测性优化,尝试预测用户的下一次操
		作。然后,预先解析 DNS、预先连接可能的目标。
		
		
好消息是,所有这些优化都由浏览器替我们自动完成,经常可以节省几百 ms 的网络延迟。既然如此,那理解这些优化背后的原理就至关重要了,这样才能利用浏览器的这些特性,提升应用性能。大多数浏览器都利用了如下四种技术。


	• 资源预取和排定优先次序
		文档、CSS 和 JavaScript 解析器可以与网络协议层沟通,声明每种资源的优先
		级:初始渲染必需的阻塞资源具有最高优先级,而低优先级的请求可能会被临时
		保存在队列中。
		
	• DNS 预解析
		对可能的域名进行提前解析,避免将来 HTTP 请求时的 DNS 延迟。预解析可以
		通过学习导航历史、用户的鼠标悬停,或其他页面信号来触发。
		
	• TCP 预连接
		DNS 解析之后,浏览器可以根据预测的 HTTP 请求,推测性地打开 TCP 连接。
		如果猜对的话,则可以节省一次完整的往返(TCP 握手)时间。
		
	• 页面预渲染
		某些浏览器可以让我们提示下一个可能的目标,从而在隐藏的标签页中预先渲染
		整个页面。这样,当用户真的触发导航时,就能立即切换过来。
